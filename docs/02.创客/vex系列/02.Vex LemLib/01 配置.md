---
title: vex LemLib的配置
date: 2025-11-06 01:24:35
permalink: /steam/vex/vex-lemllib-configuration
categories:
  - vex系列、vex LemLib
tags:
  - vex LemLib

---

## 引言

既然 LemLib 已安装，我们在开始使用它之前需要对其进行配置。大多数错误都发生在配置期间，因此请密切注意说明。

## 传动系统

首先，我们需要配置我们传动系统上的电机。每个电机有三个属性：连接的端口、是否反转以及安装的墨盒（又名变速箱）。

>[success] 从机器人的角度来看，电机在机器人的左侧。


让我们首先确定机器人上的电机。我们需要弄清楚它们连接到哪些端口。这可以通过进入大脑上的设备菜单并观察拔下电机时哪个端口消失来完成。记录哪个电机连接到哪个端口。现在，实例化电机对象：
>电机应在函数外部创建，靠近文件顶部。

>[success] pros::MotorGroup left_motors({1, 2, 3}); // 左侧电机在端口 1、2、3
>[success] pros::MotorGroup right_motors({4, 5, 6}); // 右侧电机在端口 4、5、6


> 请记住，在文件顶部需要有`#include "lemlib/api.hpp"`，否则到处都会有错误。

现在，我们需要确定当我们施加正电压时电机的旋转方向。这可以通过在大脑屏幕上的设备菜单中移动电机并观察驱动轮的移动方式来完成。请参阅下表以确定电机是否反转：

>这需要对传动系统上的所有电机进行。


|                   | **顺时针**         | **逆时针** |
| ----------------- | --------------------- | --------------------- |
|    **左侧**       | 反转                | 前进                |
|    **右侧**      | 前进                | 反转                |

现在，让我们更新我们的配置。如果电机反转，它的端口为负。如果它是正向的（未反转），它的端口为正：

```cpp
pros::MotorGroup left_motors({-1, 2, -3}); // 左侧电机在端口 1（反转）、2（正向）和 3（反转）
pros::MotorGroup right_motors({4, -5, 6}); // 右侧电机在端口 4（正向）、5（反转）和 6（正向）
```

现在，我们需要指定每个电机使用的墨盒。可以通过查看电机轴下方的区域来检查墨盒。电机可以有三种墨盒之一：

|          **颜色**         |         **转数**         | **代码表示**     |
| -------------------------- | ----------------------- | --------------------------- |
| **红色**                    |           100           | `pros::MotorGearset::red`   |
| **绿色**                  |           200           | `pros::MotorGearset::green` |
| **蓝色**                   |           600           | `pros::MotorGearset::blue`  |

我们也需要在代码中指定墨盒配置：

```cpp
pros::MotorGroup left_motors({-1, 2, -3}, pros::MotorGearset::blue); // 左侧电机使用 600 转/分钟的墨盒
pros::MotorGroup right_motors({4, -5, 6}, pros::MotorGearset::green); // 右侧电机使用 200 转/分钟的墨盒
```

现在我们的电机已完全配置好，我们需要将它们传递给 LemLib。我们可以通过一个辅助类“Drivetrain”来做到这一点。它需要以下信息：
 - 左侧电机组
 - 右侧电机组
 - 履带宽度
 - 车轮直径
 - 水平偏移

### 履带宽度

履带宽度是从传动系统的左侧到右侧的距离。具体来说，是从车轮的中间测量。履带宽度如下图所示：

![track_width](https://file.sakaay.com/sakaay/vex%20pic/track_width.webp)


记录履带宽度，我们很快就会需要它。

### 车轮直径

这个应该是不言而喻的。它是你的传动系统上车轮的直径。车轮的实际直径与 Vex 宣传的直径略有不同（正如 Vex 的典型情况，这在任何地方都没有记录）。因此，LemLib 为所有不同的车轮包含了常量，如下所示：

```{Note}
如果出于任何原因你想要自定义车轮尺寸：你可以输入一个数字而不是一个常量。
```

| **车轮类型**     | **实际尺寸** | **LemLib 常量**               |
| ------------------ | --------------- | --------------------------------- |
| New 2"             | 2.125           | `lemlib::Omniwheel::NEW_2`        |
| New 2.75"          | 2.75            | `lemlib::Omniwheel::NEW_275`      |
| Old 2.75"          | 2.75            | `lemlib::Omniwheel::OLD_275`      |
| Half-Cut New 2.75" | 2.744           | `lemlib::Omniwheel::NEW_275_HALF` |
| Half-Cut Old 2.75" | 2.74            | `lemlib::Omniwheel::OLD_275_HALF` |
| New 3.25"          | 3.25            | `lemlib::Omniwheel::NEW_325`      |
| Old 3.25"          | 3.25            | `lemlib::Omniwheel::OLD_325`      |
| Half-Cut New 3.25" | 3.246           | `lemlib::Omniwheel::NEW_325_HALF` |
| Half-Cut Old 3.25" | 3.246           | `lemlib::Omniwheel::OLD_325_HALF` |
| New 4"             | 4.00            | `lemlib::Omniwheel::NEW_4`        |
| Old 4"             | 4.18            | `lemlib::Omniwheel::OLD_4`        |
| Half-Cut New 4"    | 3.995           | `lemlib::Omniwheel::NEW_4_HALF`   |
| Half-Cut Old 4"    | 4.175           | `lemlib::Omniwheel::OLD_4_HALF`   |

记录车轮直径，我们很快就会需要它。

### 水平偏移

不要担心水平偏移，我们将在调优教程中介绍它。目前，只需将其设置为 2。

### 配置

现在我们有了配置传动系统所需的所有必要信息。我们将使用“Drivetrain”类来存储此信息，如下例所示：

```{Important}
这需要在电机和电机组创建后创建，并且必须在函数外部。
```

```cpp
// 传动系统设置
lemlib::Drivetrain drivetrain(&left_motor_group, // 左侧电机组
                              &right_motor_group, // 右侧电机组
                              10, // 10 英寸履带宽度
                              lemlib::Omniwheel::NEW_4, // 使用新 4 英寸全向轮
                              360, // 传动系统转速为 360
                              2 // 水平偏移为 2（目前）
);
```

## 里程计

里程计是跟踪机器人位置的算法。它通过内部电机编码器（IME）和/或跟踪轮和/或 V5 惯性传感器（IMU）来实现。我们需要配置这些传感器，以便 LemLib 可以与它们交互。

### IMU

对于 IMU，我们只需要找到它连接的端口。进入大脑屏幕上的设备菜单，查看 IMU 连接到哪个端口。请参阅以下代码示例以在代码中创建 IMU：

```cpp
// 在端口 10 创建一个 IMU
pros::Imu imu(10);
```

### 跟踪轮

```{Important}
垂直跟踪轮与传动系统上的车轮平行。水平跟踪轮与传动系统上的车轮垂直。
```

跟踪轮是带有编码器的独立车轮。请参见下图：

![tracking_wheel](https://file.sakaay.com/sakaay/vex%20pic/tracking_wheel.webp)

LemLib 可以在任何跟踪设置下工作，但有些设置的性能比其他设置好得多。请参阅下表：

###### 航向跟踪：

| 推荐 | 可接受                  | 不推荐   |
| ----------- | --------------------------- | ----------------- |
| 1x IMU      | 2x 平行跟踪轮 | IMEs              |

###### 横向位置跟踪

横向位置跟踪有更多可能的配置。让我们从推荐的垂直跟踪开始：

| 推荐                | 可接受 |
| -------------------------- | ---------- |
| 1x 垂直跟踪轮 | IMEs       |

推荐的水平跟踪：

| 推荐                  | 可接受      | 不推荐           |
| ---------------------------- | --------------- | ------------------------- |
| 1x 水平跟踪轮 | 牵引轮 | 仅全向轮传动系统 |

即使你有牵引轮，也建议使用水平跟踪轮，因为即使有牵引轮，机器人仍然可以稍微水平滑动。如果你的传动系统仅使用全向轮，则强烈建议使用水平跟踪轮，因为机器人可以在水平方向上大量漂移。

```{Tip}
最佳跟踪设置是 1x IMU、1x 垂直跟踪轮、1x 水平跟踪轮。
```

#### 编码器

```{Note}
如果你不使用跟踪轮，可以跳过此部分。
```

跟踪轮可以使用[光学轴编码器](https://www.vexrobotics.com/276-2156.html)或[V5 旋转传感器](https://www.vexrobotics.com/276-6050.html)。在我们的测试中，精度没有差异。使用最方便的那个。

跟踪轮需要编码器，编码器有两个我们需要知道的属性：它们连接的端口以及是否应反转。

首先，我们需要创建编码器。对于两种不同的传感器，过程是不同的：

##### 光学轴编码器

```{Important}
光学轴编码器使用 2 个 ADI（三端口）端口。然而，只有少数有效的端口组合，如下所示：
('A', 'B'); ('C', 'D'); ('E', 'F'); ('G', 'H')
```

```cpp
// 创建连接到端口'A'和'B'的光学轴编码器
pros::adi::Encoder adi_encoder('A', 'B');
```

##### V5 旋转传感器

对于此目的，V5 旋转传感器与光学轴编码器相同。区别在于它使用 V5 智能端口，而不是 ADI 端口。请参见以下示例：

```cpp
// 在端口 1 创建一个 V5 旋转传感器
pros::Rotation rotation_sensor(1);
```

##### 确定反转

接下来，我们需要确定编码器是否反转。我们将通过将它们的值打印到大脑屏幕上来确定这一点。使用下面的代码片段将编码器读数打印到大脑：

```{Important}
在确定跟踪轮是否应反转后，删除 initialize 中的 while 循环。
```

```cpp
// 将'A'，'B'替换为传感器连接的端口
pros::adi::Encoder vertical_encoder('A', 'B');
// 将 1 替换为旋转传感器连接的端口
pros::Rotation horizontal_sensor(1);

// 这在程序开始时运行
void initialize() {
    pros::lcd::initialize(); // 初始化大脑屏幕
    while (true) { // 无限循环
        // 打印 ADI 编码器的测量值
        pros::lcd::print(0, "ADI Encoder: %i", adi_encoder.get_value());
        // 打印旋转传感器的测量值
        pros::lcd::print(1, "Rotation Sensor: %i", rotation_sensor.get_position());
        pros::delay(10); // 延迟以节省资源。请勿删除。
    }
}
```

```{Tip}
如果传感器读数没有变化或显示非常大的数字（>1000000），你可能为传感器指定了错误的端口。
```

在你的程序中使用此代码片段并运行它。当你向前推动机器人时，垂直编码器的测量位置应增加。如果它们减少，则传感器需要反转。当你将机器人向右推（相对于机器人）时，水平编码器测量的位置应增加。如果它们减少，则传感器需要反转。

要反转 ADI 编码器，只需在端口后将`true`传递给编码器构造函数。对于旋转传感器，像电机一样将端口号设为负。请参见以下示例：

```cpp
// 反转的 ADI 编码器
pros::adi::Encoder adi_encoder('A', 'B', true);
// 反转的旋转传感器
pros::Rotation rotation_sensor(-1);
```

#### 偏移量

现在我们已经配置了编码器，我们需要确定跟踪轮的偏移量。跟踪轮的偏移量等于垂直于它并终止于跟踪中心的线的长度。为了帮助我们理解，让我们看一下下面的图：

![tracking_wheel_distance](https://file.sakaay.com/sakaay/vex%20pic/tracking_wheel_distance.webp)

在图中，有三个跟踪轮：左侧一个垂直跟踪轮，偏移量为 4.6"，右侧一个垂直跟踪轮，偏移量为 1.7"，后面一个水平跟踪轮，偏移量为 4.5"。

跟踪轮的偏移量可以是正的也可以是负的，这取决于它是垂直轮还是水平轮以及它相对于跟踪中心的位置。请参阅下表：

###### 垂直跟踪轮

| 位置 | 符号 |
| -------- | ---- |
| 左侧 | -    |
| 右侧 | +    |

###### 水平跟踪轮

| 位置 | 符号 |
| -------- | ---- |
| 后面 | -    |
| 前面 | +    |

#### 车轮直径

如前所述，车轮的市场宣传直径与实际直径不匹配。有关更多信息，请参阅“传动系统”教程中的“车轮直径”部分。

#### 齿轮比

用户可能希望为他们的跟踪轮配备齿轮。与你的预期相反，这不是为了增加传感器的精度。相反，跟踪轮可能配备齿轮以使它们更薄。齿轮比等于从动齿轮的齿数除以主动齿轮的齿数。如果你不为跟踪轮配备齿轮，则齿轮比等于 1。

#### 配置

现在我们知道了跟踪轮的所有属性，我们可以在代码中初始化我们的跟踪轮：

```cpp
// 水平跟踪轮编码器
pros::Rotation horizontal_encoder(20);
// 垂直跟踪轮编码器
pros::adi::Encoder vertical_encoder('C', 'D', true);
// 水平跟踪轮
lemlib::TrackingWheel horizontal_tracking_wheel(&horizontal_encoder, lemlib::Omniwheel::NEW_275, -5.75);
// 垂直跟踪轮
lemlib::TrackingWheel vertical_tracking_wheel(&vertical_encoder, lemlib::Omniwheel::NEW_275, -2.5);
```

### 配置

现在我们已经配置了所有我们需要的传感器，用于：

```cpp
lemlib::OdomSensors sensors(&vertical_tracking_wheel, // 垂直跟踪轮 1，设置为 null
                            nullptr, // 垂直跟踪轮 2，设置为 null，因为我们正在使用 IMEs
                            &horizontal_tracking_wheel, // 水平跟踪轮 1
                            nullptr, // 水平跟踪轮 2，设置为 null，因为我们没有第二个
                            &imu // 惯性传感器
);
```

## PIDs

在本教程中我们不会调整 PIDs，但我们将在下一个教程中进行调整。目前，只需将以下代码复制/粘贴到你的项目中：

```cpp
// 横向 PID 控制器
lemlib::ControllerSettings lateral_controller(10, // 比例增益（kP）
                                              0, // 积分增益（kI）
                                              3, // 微分增益（kD）
                                              3, // 抗积分饱和
                                              1, // 小误差范围，以英寸为单位
                                              100, // 小误差范围超时，以毫秒为单位
                                              3, // 大误差范围，以英寸为单位
                                              500, // 大误差范围超时，以毫秒为单位
                                              20 // 最大加速度（斜率）
);

// 角度 PID 控制器
lemlib::ControllerSettings angular_controller(2, // 比例增益（kP）
                                              0, // 积分增益（kI）
                                              10, // 微分增益（kD）
                                              3, // 抗积分饱和
                                              1, // 小误差范围，以度为单位
                                              100, // 小误差范围超时，以毫秒为单位
                                              3, // 大误差范围，以度为单位
                                              500, // 大误差范围超时，以毫秒为单位
                                              0 // 最大加速度（斜率）
);
```

## 最终配置

现在我们有了配置 LemLib 所需的所有必要信息。请参见下面的代码块：

```cpp
// 左侧电机组
pros::MotorGroup left_motor_group({-1, 2, -3}, pros::MotorGears::blue);
// 右侧电机组
pros::MotorGroup right_motor_group({4, -5, 6}, pros::MotorGears::green);

// 传动系统设置
lemlib::Drivetrain drivetrain(&left_motor_group, // 左侧电机组
                              &right_motor_group, // 右侧电机组
                              10, // 10 英寸履带宽度
                              lemlib::Omniwheel::NEW_4, // 使用新 4 英寸全向轮

```

> 本文来自 [LemLib](https://lemlib.readthedocs.io/en/stable），经翻译发布于此以供大家学习使用！侵删！