---
title: vex LemLib的驾驶员控制
date: 2025-11-06 01:24:35
permalink: /steam/vex/vex-lemllib-driver-control
categories:
  - vex系列
tags:
  - vex LemLib

---
## 介绍
在本教程中，我们将学习如何对传动系统进行编程，以实现控制器操纵杆输入。

## 控制器
控制器有两个操纵杆。一个“左”操纵杆和一个“右”操纵杆。每个操纵杆有两个轴，一个“x”轴和一个“y”轴。我们将使用这些轴来控制传动系统。

## 坦克驾驶
坦克驾驶是一种控制传动系统的简单方法。你为左轮提供动力，为右轮提供动力。在这个例子中，我们将使用“左 y”轴和“右 y”轴。

```cpp
pros::Controller controller(pros::E_CONTROLLER_MASTER);

void opcontrol() {
    // 永远循环
    while (true) {
        // 获取左 y 和右 y 位置
        int leftY = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int rightY = controller.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_Y);

        // 移动机器人
        chassis.tank(leftY, rightY);

        // 延迟以节省资源
        pros::delay(25);
    }
}
```

## 街机驾驶
街机驾驶是控制机器人最流行的形式。在街机控制中，我们给机器人一个前进/后退速度和一个转弯速度。下面是两个例子：单杆街机和双杆街机。

### 单杆街机

```cpp
pros::Controller controller(pros::E_CONTROLLER_MASTER);

void opcontrol() {
    // 永远循环
    while (true) {
        // 获取左 y 和右 x 位置
        int leftY = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int leftX = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_X);

        // 移动机器人
        chassis.arcade(leftY, leftX);

        // 延迟以节省资源
        pros::delay(25);
    }
}
```

### 双杆街机

```cpp
pros::Controller controller(pros::E_CONTROLLER_MASTER);

void opcontrol() {
    // 永远循环
    while (true) {
        // 获取左 y 和右 x 位置
        int leftY = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int rightX = controller.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X);

        // 移动机器人
        chassis.arcade(leftY, rightX);

        // 延迟以节省资源
        pros::delay(25);
    }
}
```

### 油门/转向优先级

> 本节是可选的，不是控制机器人所必需的。


你可以优先考虑转向而不是转弯，反之亦然。例如，你可以完全优先考虑转向，以便对于给定的转向输入，无论油门输入如何，机器人的角速度都保证相同。使用 LemLib，你可以通过一个设定的量（从 0 到 1）优先考虑转向而不是油门。0.5 是默认值，此时转向和转弯具有相同的优先级。0 完全优先考虑油门，而 1 完全优先考虑转向。请参见下面的代码块：

```cpp
pros::Controller controller(pros::E_CONTROLLER_MASTER);

void opcontrol() {
    // 永远循环
    while (true) {
        // 获取左 y 和右 x 位置
        int leftY = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int leftX = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_X);

        // 移动机器人
        // 稍微优先考虑转向
        chassis.arcade(leftY, leftX, false, 0.75);

        // 延迟以节省资源
        pros::delay(25);
    }
}
```

## 曲率驾驶
曲率驾驶是一种不太为人所知但功能强大的方法。我们给机器人一个前进/后退速度和一个弧线的曲率。曲率越大，机器人转弯越多。它与街机驾驶类似，但在转弯时表现更好。下面是单杆和双杆曲率驾驶的示例：

### 单杆曲率

```cpp
pros::Controller controller(pros::E_CONTROLLER_MASTER);

void opcontrol() {
    // 永远循环
    while (true) {
        // 获取左 y 和右 x 位置
        int leftY = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int leftX = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_X);

        // 移动机器人
        chassis.curvature(leftY, leftX);

        // 延迟以节省资源
        pros::delay(25);
    }
}
```

### 双杆曲率

```cpp
pros::Controller controller(pros::E_CONTROLLER_MASTER);

void opcontrol() {
    // 永远循环
    while (true) {
        // 获取左 y 和右 x 位置
        int leftY = controller.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int rightX = controller.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X);

        // 移动机器人
        chassis.curvature(leftY, rightX);

        // 延迟以节省资源
        pros::delay(25);
    }
}
```

## 但我该选择哪种呢？
这个问题没有正确答案。驾驶员应该使用他们觉得最舒服的控制方法。

## 输入缩放

> 本节是可选的，不是控制机器人所必需的。

> 坦克控制仅使用油门曲线，不使用转向曲线。

> [Vex 论坛中的详细解释](https://www.vexforum.com/t/expo-drive-lemlibs-implementation/123337)


进行精确的移动很困难。要是有一种方法能使其不那么敏感，但又不限制最大速度就好了。嗯，有一种方法，它叫做输入缩放。输入缩放不是控制器输入和传动系统输出之间的常规线性关系，而是一种指数关系，以使小移动不那么敏感，以换取使快速移动更敏感。下面是这种关系的图像：

![curve](https://file.sakaay.com/sakaay/vex%20pic/curve.jpeg)


### 代码

```cpp
// 驾驶员控制期间油门输入的输入曲线
lemlib::ExpoDriveCurve throttle_curve(3, // 操纵杆死区，取值范围为 127
                                     10, // 传动系统开始移动的最小输出，取值范围为 127
                                     1.019 // 指数曲线增益
);

// 驾驶员控制期间转向输入的输入曲线
lemlib::ExpoDriveCurve steer_curve(3, // 操纵杆死区，取值范围为 127
                                  10, // 传动系统开始移动的最小输出，取值范围为 127
                                  1.019 // 指数曲线增益
);

// 创建底盘
lemlib::Chassis chassis(drivetrain,
                        lateral_controller,
                        angular_controller,
                        sensors,
                        &throttle_curve, 
                        &steer_curve
);
```

## 结论
这就是关于驾驶员控制的全部内容。我们将在下一个教程中介绍自主运动和调整。



> 本文来自 [LemLib](https://lemlib.readthedocs.io/en/stable），经翻译发布于此以供大家学习使用！侵删！### 三级标题