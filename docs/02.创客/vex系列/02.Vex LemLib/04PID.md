---
title: vex LemLib的PID整定
date: 2025-11-06 09:24:35
permalink: /steam/vex/vex-lemllib-pid-tuning
categories:
  - vex系列
tags:
  - vex LemLib
---

## 引言

在 LemLib 的大多数运动算法中都使用了 PID。LemLib 使用了两个 PID 控制器：一个用于横向运动，一个用于角运动。本教程将重点介绍这些 PID 的整定。

## 什么是 PID？

如果您不熟悉 PID，请查看 [BLRS Wiki](https://wiki.purduesigbots.com/software/control-algorithms/pid-controller)。

PID 是一种控制器。它控制一个机械装置。它接受一个数值输入，并返回一个数值输出。数值输入是来自传感器的测量值，数值输出是执行器（例如电机）的功率。

## 整定 PID

## 角 PID

这是我们之前复制粘贴的 PID 设置：

```cpp
lemlib::ControllerSettings angular_controller(2, // 比例增益（kP）
                                              0, // 积分增益（kI）
                                              10, // 微分增益（kD）
                                              3, // 抗积分饱和
                                              1, // 小误差范围，单位为英寸
                                              100, // 小误差范围超时时间，单位为毫秒
                                              3, // 大误差范围，单位为英寸
                                              500, // 大误差范围超时时间，单位为毫秒
                                              0 // 最大加速度（斜率）
);
```

### kP 和 kD

kP 和 kD 是最重要的设置，它们负责大部分的运动。为了调整它们，我们将首先禁用所有其他设置：

```cpp
lemlib::ControllerSettings angular_controller(2, // 比例增益（kP）
                                              0, // 积分增益（kI）
                                              10, // 微分增益（kD）
                                              0, // 抗积分饱和
                                              0, // 小误差范围，单位为英寸
                                              0, // 小误差范围超时时间，单位为毫秒
                                              0, // 大误差范围，单位为英寸
                                              0, // 大误差范围超时时间，单位为毫秒
                                              0 // 最大加速度（斜率）
);
```

我们将使用`Chassis::turnToHeading`来调整角控制器：

```cpp
void autonomous() {
    // 将位置设置为 x:0, y:0, 航向:0
    chassis.setPose(0, 0, 0);
    // 转向面对航向 90，超时时间非常长
    chassis.turnToHeading(90, 100000);
}
```

要调整 PID，请使用此流程图。重复直到没有任何数量的 kD 能阻止机器人振荡：

![pd_tuning_flowchart](https://file.sakaay.com/sakaay/vex%20pic/pd_tuning_flowchart.webp)

### kI 和抗积分饱和范围

> kI 应该仅在 kP 和 kD 无法调整到令人满意的程度时作为最后手段使用，这种情况很少见。

> 这需要在调整 kP 和 kD 之后进行。

> 在调整 kI 时，应禁用除 kP 和 kD 之外的所有增益。

> 稳态误差是机器人停止移动后机器人与目标之间的距离。

kI 是积分增益。它用于校正稳态误差。这通常用于速度控制器而不是位置控制器，但在某些情况下对于位置控制器是必要的。

首先，我们需要确定运动后的稳态误差范围。为此，记录平均稳态误差。要记录平均稳态误差，请在 10 度到 180 度之间移动机器人并记录平均稳态误差。然后将其增加 50%。这是抗积分饱和范围。将新的抗积分饱和范围输入到设置中。但是什么是抗积分饱和范围呢？抗积分饱和范围是控制器的积分部分可以增加的范围。如果误差在这个范围之外，积分将被设置为 0。这是为了防止在长时间运动中超过目标。

现在我们有了抗积分饱和范围，我们需要调整 kI。重复以下过程直到满意：
![pd_tuning_flowchart](https://file.sakaay.com/sakaay/vex%20pic/i_tuning_flowchart.webp)


当该过程完成时，输入您的新 kI 增益。

### 斜率

> 限制角加速度是极其罕见的。除非您知道自己在做什么，否则请跳过此部分。

斜率用于限制角加速度。除了极端情况外，实际上没有任何情况需要这样做。例如：一个 70 磅的 VEXU 机器人如果加速太快会很快烧毁其电机。

斜率为 0 会禁用加速度限制。较高的值允许机器人更快地加速。例如，值为 127 将允许机器人在 10 毫秒内从静止加速到最大速度。

由于除了极端情况外没有角加速度限制的用例，本文档将不涵盖角斜率的调整。

## 横向 PID

这是我们之前复制粘贴的 PID 设置：

```cpp
lemlib::ControllerSettings lateral_controller(10, // 比例增益（kP）
                                              0, // 积分增益（kI）
                                              3, // 微分增益（kD）
                                              3, // 抗积分饱和
                                              1, // 小误差范围，单位为英寸
                                              100, // 小误差范围超时时间，单位为毫秒
                                              3, // 大误差范围，单位为英寸
                                              500, // 大误差范围超时时间，单位为毫秒
                                              20 // 最大加速度（斜率）
);
```

### kP 和 kD

kP 和 kD 是最重要的设置，它们负责大部分的运动。为了调整它们，我们将首先禁用所有其他设置：

```cpp
lemlib::ControllerSettings lateral_controller(10, // 比例增益（kP）
                                              0, // 积分增益（kI）
                                              3, // 微分增益（kD）
                                              0, // 抗积分饱和
                                              0, // 小误差范围，单位为英寸
                                              0, // 小误差范围超时时间，单位为毫秒
                                              0, // 大误差范围，单位为英寸
                                              0, // 大误差范围超时时间，单位为毫秒
                                              0 // 最大加速度（斜率）
);
```

要调整 PID，请使用此流程图。重复直到没有任何数量的 kD 能阻止机器人振荡：

![pd_tuning_flowchart](https://file.sakaay.com/sakaay/vex%20pic/pd_tuning_flowchart.webp)


当此过程完成时，使用设置中的找到的值并恢复禁用的增益：

```cpp
lemlib::ControllerSettings lateral_controller(10, // 比例增益（kP）
                                              0, // 积分增益（kI）
                                              3, // 微分增益（kD）
                                              3, // 抗积分饱和
                                              1, // 小误差范围，单位为英寸
                                              100, // 小误差范围超时时间，单位为毫秒
                                              3, // 大误差范围，单位为英寸
                                              500, // 大误差范围超时时间，单位为毫秒
                                              20 // 最大加速度（斜率）
);
```

### kI 和抗积分饱和范围

> kI 应该仅在 kP 和 kD 无法调整到令人满意的程度时作为最后手段使用，这种情况很少见。

> 这需要在调整 kP 和 kD 之后进行。

> 在调整 kI 时，应禁用除 kP 和 kD 之外的所有增益。

> 稳态误差是机器人停止移动后机器人与目标之间的距离。

kI 是积分增益。它用于校正稳态误差。这通常用于速度控制器而不是位置控制器，但在某些情况下对于位置控制器是必要的。

首先，我们需要确定运动后的稳态误差范围。为此，记录平均稳态误差。要记录平均稳态误差，请在 5 英寸到 48 英寸之间移动机器人并记录平均稳态误差。然后将其增加 50%。这是抗积分饱和范围。将新的抗积分饱和范围输入到设置中。但是什么是抗积分饱和范围呢？抗积分饱和范围是控制器的积分部分可以增加的范围。如果误差在这个范围之外，积分将被设置为 0。这是为了防止在长时间运动中超过目标。

现在我们有了抗积分饱和范围，我们需要调整 kI。重复以下过程直到满意：

![i_tuning_flowchart](https://file.sakaay.com/sakaay/vex%20pic/i_tuning_flowchart.webp)

当该过程完成时，输入您的新 kI 增益。

### 斜率

> 调整斜率是可选的。通常仅在使用内部电机编码器进行跟踪或机器人容易倾斜时使用。

> 调整斜率应在调整 kP 和 kD 之后进行。

斜率限制机器人的加速速度。当您使用内部电机编码器进行位置跟踪时，或者如果您的机器人容易倾斜，这很有用。

斜率值为 0 会禁用它。较高的斜率值允许机器人更快地加速。例如，斜率为 127 将允许机器人在 10 毫秒内从静止加速到全速。

要调整斜率，您首先需要确定为什么首先需要调整它。

#### 防止车轮打滑

如果您没有垂直跟踪轮，则应使用斜率来防止车轮打滑。需要防止车轮打滑，以便位置跟踪保持准确。在这种情况下调整斜率时，选择一个高的斜率值：127。然后，使用下面的代码片段将机器人向前移动 48 英寸（相当于 2 个场地瓷砖）：

```cpp
void autonomous() {
     // 将位置设置为 x:0, y:0, 航向:0
    chassis.setPose(0, 0, 0);
    // 向前移动 48 英寸
    chassis.moveToPoint(0, 48, 10000);
}
```

如果您认为跟踪可以更准确，请尝试减小斜率并再次运行程序。重复直到减小斜率不会影响准确性。

#### 防止机器人倾斜

如果您想防止机器人倾斜，则需要调整斜率。首先，将斜率设置为高值：127。然后，使用下面的代码片段将机器人向前移动 48 英寸（相当于 2 个场地瓷砖）：

```cpp
void autonomous() {
     // 将位置设置为 x:0, y:0, 航向:0
    chassis.setPose(0, 0, 0);
    // 向前移动 48 英寸
    chassis.moveToPoint(0, 48, 10000);
}
```

减小斜率以使机器人倾斜更少。再次运行程序并减小斜率，直到机器人不再倾斜。

## 退出条件

退出条件确定运动何时退出。运动有 3 个退出条件：

 - 超时
 - 当机器人在目标的一定范围内时的短超时
 - 当机器人在目标的一定小范围内时的非常短超时

主超时用于发生意外情况时，例如当机器人与另一个机器人碰撞时。这允许自主程序继续进行下一个运动，在那里它可以潜在地恢复。

其他两个超时用于当机器人接近目标时。有一个较长的超时和一个较短的超时。例如：

 - 如果机器人在目标的 5 英寸范围内持续 500 毫秒，则退出
 - 如果机器人在目标的 1 英寸范围内持续 100 毫秒，则退出

这些退出条件在 PID 设置构造函数中进行调整。请参见下面的代码示例：

```cpp
lemlib::ControllerSettings lateral_controller(10, // 比例增益（kP）
                                              0, // 积分增益（kI）
                                              3, // 微分增益（kD）
                                              3, // 抗积分饱和
                                              1, // 小误差范围，单位为英寸
                                              100, // 小误差范围超时时间，单位为毫秒
                                              3, // 大误差范围，单位为英寸
                                              500, // 大误差范围超时时间，单位为毫秒
                                              20 // 最大加速度（斜率）
);
```

现在您已经调整了 PID！


> 本文来自 [LemLib](https://lemlib.readthedocs.io/en/stable），经翻译发布于此以供大家学习使用！侵删！